
%{
  open SimpleC
%}

%token TRUE FALSE
%token IF ELSE
%token WHILE FOR
%token PRINT
%token LPAREN RPAREN LCURLY RCURLY
%token PLUS MINUS TIMES DIVIDE REMAINDER
%token NOT OR AND
%token EQ EQEQ NOTEQ LT LEQT GT GEQT
%token SEMICOLON
%token EOF
%token <float> FLOAT
%token <string> ID

/*
To fix the shift/reduce conflict of the rules:
  IF LPAREN boolean RPAREN body
  IF LPAREN boolean RPAREN body ELSE body
*/
%nonassoc THEN
%nonassoc ELSE

/*
Another typical way to do the same thing would be:
%right "then" "else"
Same precedence, but "shift else" wins.
*/

/*
It's not really necessary, because LR parsers generated by YACC
resolve shift/reduce conflicts by performing the shift. That is, the
ambiguity of
  if <cond> then if <cond> then <stm> else <stm>
is resolved by assigning the else branch to the nearest if (in this
case, to the second if).
*/

/*
The expression precedence is as follows: (lowest to highest)
  "or" operator, left associative
  "and" operator, left associative
  "not" operator, nonassociative
  "relational" operators, left associative
  "+" and "-" operators, left associative
  "*" and "/" operators, left associative
  "unary -" operator, nonassociative
*/
%left OR
%left AND
%nonassoc NOT
%left EQEQ NOTEQ LT LTEQ GT GTEQ
%left PLUS MINUS
%left TIMES DIVIDE REMAINDER
%nonassoc UNARY_MINUS

%start s
%type <SimpleC.statement list> s

%%

s :
    statement_list EOF
      { $1 }
;

statement_list :
    /* empty */
      { [] }
  | statement SEMICOLON statement_list
      { $1 :: $3 }
;

statement :
    ID EQ arith
      { Bind ($1, $3) }
  | IF LPAREN boolean RPAREN body
    %prec THEN
      { If ($3, $5, []) }
  | IF LPAREN boolean RPAREN body ELSE body
    %prec ELSE
      { If ($3, $5, $7) }
  | WHILE LPAREN boolean RPAREN body
      { While ($3, $5) }
  | FOR LPAREN statement SEMICOLON boolean SEMICOLON statement RPAREN body
      { For ($3, $5, $7, $9) }
  | PRINT arith
      { Print $2 }

body :
    statement
      { [$1] }
  | LCURLY statement_list RCURLY
      { $2 }

arith :
    FLOAT
      { C $1 }
  | ID
      { Var $1 }
  | arith PLUS arith
      { Arith_bi_op (Sum, $1, $3) }
  | arith MINUS arith
      { Arith_bi_op (Sub, $1, $3) }
  | arith TIMES arith
      { Arith_bi_op (Prod, $1, $3) }
  | arith DIVIDE arith
      { Arith_bi_op (Div, $1, $3) }
  | arith REMAINDER arith
      { Arith_bi_op (Mod, $1, $3) }
  | MINUS arith
    %prec UNARY_MINUS
      { Arith_op (Opp, $2) }
  | LPAREN arith RPAREN
      { $2 }
;

boolean :
    TRUE
      { B true }
  | FALSE
      { B false }
  | NOT boolean
      %prec NOT
      { Boolean_op (Not, $2) }
  | boolean OR boolean
      { Boolean_bi_op (Or, $1, $3) }
  | boolean AND boolean
      { Boolean_bi_op (And, $1, $3) }
  | arith EQEQ arith
      { Comp (Equal, $1, $3)}
  | arith NOTEQ arith
      { Comp (Not_equal, $1, $3)}
  | arith LT arith
      { Comp (Less, $1, $3)}
  | arith LEQT arith
      { Comp (Less_equal, $1, $3)}
  | arith GT arith
      { Comp (Greater, $1, $3)}
  | arith GEQT arith
      { Comp (Greater_equal, $1, $3)}
  | LPAREN boolean RPAREN
      { $2 }
;

